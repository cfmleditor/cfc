diff --git a/src/compiler/binder.ts b/src/compiler/binder.ts
index 10827ec..636f1c8 100644
--- a/src/compiler/binder.ts
+++ b/src/compiler/binder.ts
@@ -914,7 +914,7 @@ export function Binder() {
                 const firstAccessElement = target.accessElements[0];
                 let firstAccessAsString : string | undefined = undefined;
                 if (firstAccessElement.accessType === IndexedAccessType.dot) {
-                    firstAccessAsString = firstAccessElement.property.token.text.toLowerCase();
+                    firstAccessAsString = firstAccessElement.property.token.text;
                 }
                 else if (firstAccessElement.accessType === IndexedAccessType.bracket) {
                     firstAccessAsString = getTriviallyComputableString(firstAccessElement.expr)
diff --git a/src/compiler/checker.ts b/src/compiler/checker.ts
index a7c15c6..9efc2e6 100644
--- a/src/compiler/checker.ts
+++ b/src/compiler/checker.ts
@@ -296,8 +296,26 @@ export function Checker() {
                 return;
             case NodeKind.typeShim:
                 return;
-            case NodeKind.property:
+            case NodeKind.property: {
+                // if we're in Wirebox mode, and the property has an inject attribute that we can resolve, add the type to the property value
+                if (sourceFile.libRefs.has("<<magic/wirebox>>")) {
+                    const nameAttrVal = getAttributeValue(node.attrs, "name");
+                    const nameStringVal = getTriviallyComputableString(nameAttrVal)?.toLowerCase();
+                    const injectAttrVal = getAttributeValue(node.attrs, "inject");
+                    const injectStringVal = getTriviallyComputableString(injectAttrVal)?.toLowerCase();
+                    if (!injectStringVal || !nameStringVal) return;
+
+                    const mappings = sourceFile.libRefs.get("<<magic/wirebox>>")!.containedScope.typedefs.mergedInterfaces.get("Wirebox")?.members.get("mappings");
+                    const targetSymbol = sourceFile.containedScope.variables!.get(nameStringVal);
+                    if (!mappings || !targetSymbol || !isStructLike(mappings.type)) return;
+
+                    const cfc = mappings.type.members.get(injectStringVal);
+                    if (!cfc) return;
+
+                    targetSymbol.declaredType = cfc.type;
+                }
                 return;
+            }
             case NodeKind.paramStatement:
                 return;
             default:
@@ -1626,8 +1644,8 @@ export function Checker() {
                 }
                 if (node.kind === NodeKind.sourceFile) {
                     for (const lib of node.libRefs.values()) {
-                        if (lib.containedScope.typedefs.interfaces.has(type.name)) {
-                            return lib.containedScope.typedefs.interfaces.get(type.name)![0]; // no interface merging in libraries (or at least autogen'd libraries) yet
+                        if (lib.containedScope.typedefs.mergedInterfaces.has(type.name)) {
+                            return lib.containedScope.typedefs.mergedInterfaces.get(type.name)!;
                         }
                     }
                     break;
diff --git a/src/compiler/node.ts b/src/compiler/node.ts
index 51e3307..6a7d940 100644
--- a/src/compiler/node.ts
+++ b/src/compiler/node.ts
@@ -2373,7 +2373,6 @@ export namespace Tag {
             startTag: CfTag.Common,
             endTag: null
         }
-        attrs: TagAttribute[]
     }
 
     export function Property(tag: CfTag.Common) : Property {
diff --git a/src/compiler/project.ts b/src/compiler/project.ts
index a9985ae..5437ef2 100644
--- a/src/compiler/project.ts
+++ b/src/compiler/project.ts
@@ -6,7 +6,7 @@ import { Checker } from "./checker";
 import { BlockType, CallExpression, mergeRanges, Node, NodeId, NodeKind, SourceFile, StatementType, SymTabEntry } from "./node";
 import { Parser } from "./parser";
 import { CfFileType, SourceRange } from "./scanner";
-import { CfcTypeWrapper, cfFunctionOverloadSet, cfFunctionSignatureParam, Interface, createLiteralType, _Type } from "./types";
+import { CfcTypeWrapper, cfFunctionOverloadSet, cfFunctionSignatureParam, Interface, createLiteralType, _Type, Struct } from "./types";
 
 import { cfmOrCfc, findNodeInFlatSourceMap, flattenTree, getAttributeValue, getComponentAttrs, getComponentBlock, getTriviallyComputableString, NodeSourceMap, visit } from "./utils";
 
@@ -254,7 +254,7 @@ export function Project(__const__projectRoot: string, fileSystem: FileSystem, op
             const wireboxInterface = constructWireboxInterface(sourceFile);
             if (wireboxInterface) {
                 if (!wireboxLib) wireboxLib = SourceFile("<<magic/wirebox>>", CfFileType.dCfm, "");
-                wireboxLib.containedScope.typedefs.interfaces.set("Wirebox", [wireboxInterface]);
+                wireboxLib.containedScope.typedefs.mergedInterfaces.set("Wirebox", wireboxInterface);
             }
             else {
                 wireboxLib = null;
@@ -304,6 +304,7 @@ export function Project(__const__projectRoot: string, fileSystem: FileSystem, op
         }
 
         const overloads : {params: cfFunctionSignatureParam[], returns: _Type}[] = [];
+        const mappingsBuilder = new Map<string, SymTabEntry>();
         for (const mapping of mappings) {
             if (mapping.kind === "dir") {
                 const dirTarget = fileSystem.join(projectRoot, ...mapping.target.split("."));
@@ -327,7 +328,15 @@ export function Project(__const__projectRoot: string, fileSystem: FileSystem, op
                         const instantiableNameAsLiteralType = createLiteralType(instantiableName);
 
                         const param = cfFunctionSignatureParam(/*required*/true, instantiableNameAsLiteralType, "name")
-                        overloads.push({params: [param], returns: CfcTypeWrapper(file.parsedSourceFile)});
+                        var cfcTypeWrapper = CfcTypeWrapper(file.parsedSourceFile);
+                        overloads.push({params: [param], returns: cfcTypeWrapper});
+                        const canonicalName = instantiableName.toLowerCase();
+                        mappingsBuilder.set(canonicalName, {
+                            canonicalName,
+                            uiName: instantiableName,
+                            type: cfcTypeWrapper,
+                            declarations: null
+                        });
                     }
                 }
             }
@@ -340,7 +349,16 @@ export function Project(__const__projectRoot: string, fileSystem: FileSystem, op
             type: cfFunctionOverloadSet("getInstance", overloads, [])
         };
 
-        const wireboxMembers = new Map<string, SymTabEntry>([["getinstance", wireboxGetInstanceSymbol]]);
+        const wireboxMembers = new Map<string, SymTabEntry>([
+            ["getinstance", wireboxGetInstanceSymbol],
+            ["mappings", {
+                canonicalName: "mappings",
+                uiName: "mappings",
+                declarations: null,
+                type: Struct(mappingsBuilder)
+            }]
+        ]);
+        
         return Interface("Wirebox", wireboxMembers);
     }
 
@@ -524,12 +542,11 @@ export function Project(__const__projectRoot: string, fileSystem: FileSystem, op
             const components = parsedPath.dir.split(fileSystem.pathSep);
             const result : string[] = [];
 
-            while (components.length > 0) {
-                components.pop();
-                const workingPath = fileSystem.normalize(fileSystem.join(...components));
-
+            while (components.length > 0 && components[components.length-1] !== "" /* a removed, leading path separator turned to "" on split */) {
+                const workingPath = fileSystem.join(parsedPath.root, ...components);
+                
                 if (!workingPath.startsWith(projectRoot)) break; // should never happen ? i.e. we've climbed out of project root?
-
+                
                 const maybeModulesPath = fileSystem.join(workingPath, "modules");
                 if (fileSystem.existsSync(maybeModulesPath)) {
                     result.push(maybeModulesPath);
@@ -537,6 +554,8 @@ export function Project(__const__projectRoot: string, fileSystem: FileSystem, op
                 if (components[components.length-1] === "modules_app") { // we'll treat some/path/modules_app/ as a root
                     result.push(workingPath);
                 }
+
+                components.pop();
             }
 
             return result;
diff --git a/src/lang-server/server/src/server.ts b/src/lang-server/server/src/server.ts
index 7a7e909..8f60c4c 100644
--- a/src/lang-server/server/src/server.ts
+++ b/src/lang-server/server/src/server.ts
@@ -47,7 +47,7 @@ import { _Type } from '../../../compiler/types';
 import { FileSystem, LanguageVersion, Project } from "../../../compiler/project";
 import * as cfls from "../../../services/completions";
 import { getAttribute, getAttributeValue, getSourceFile, getTriviallyComputableString } from '../../../compiler/utils';
-import { FunctionDefinition, NodeFlags, Property } from '../../../compiler/node';
+import { BlockType, FunctionDefinition, NodeFlags, Property } from '../../../compiler/node';
 import { SourceRange, Token } from '../../../compiler/scanner';
 
 type TextDocumentUri = string;
@@ -164,6 +164,25 @@ connection.onDefinition((params) : Location[] | undefined  => {
 	const targetNode = project.getInterestingNodeToLeftOfCursor(fsPath, targetIndex);
 	if (!targetNode) return undefined;
 
+	if (targetNode.kind === NodeKind.simpleStringLiteral) {
+		if (targetNode.parent?.kind === NodeKind.tagAttribute && targetNode.parent.canonicalName === "extends") {
+			if (targetNode.parent?.parent?.kind === NodeKind.block
+					&& targetNode.parent.parent.subType === BlockType.scriptSugaredTagCallBlock
+					&& targetNode.parent.parent.name?.token.text.toLowerCase() === "component") {
+					if (sourceFile.cfc?.extends) {
+						return [{
+							uri: URI.file(sourceFile.cfc.extends.absPath).toString(),
+							range: {
+								start: {line: 0, character: 0},
+								end: {line: 0, character: 0},
+							}
+						}]
+					}
+
+			}
+		}
+		return undefined;
+	}
 	const checker = project.__unsafe_dev_getChecker();
 	const symbol = checker.getSymbol(targetNode, sourceFile);
 	if (!symbol || !symbol.symTabEntry.declarations) return undefined;
